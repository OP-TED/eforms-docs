= Notice Viewer Sample Application

To demonstrate how you can use the eForms SDK in a metadata driven application that visualises eForms notices, we have created this sample application. 

CAUTION: The notice viewer is not a production ready application. It is intended to demonstrate the use of concepts and resources available in the eForms SDK. You can use it as an inspiration or a starting point for your own apps.

== Goal

The goal of the application is to create an HTML visualisation of any given XML notice. 

NOTE: A production level application should be able to visualise any notice regardless of the version of the Forms SDK that was used to create the notice. This version of the notice viewer however, does not manage several versions of the SDK in parallel. In a future version of the application we intend to also introduce this ability for demonstration purposes.

== How it works

The notice-viewer is a command line application written in Java. It takes as a parameter the pathname of the notice XML file to visualise. The target language can also be specified (the default is English).  

The application opens the given XML file to determine the version number of the eForms SDK needed to visualise it, as well as the notice sub-type that the notice corresponds to.

Using the notice sub-type, the notice-viewer infers the appropriate EFX template needed to visualise the notice. 

The application loads the eForms metadata from its local copy of the eForms SDK and uses the EFX translator to translate the selected EFX template to XSLT.

It then uses an XSLT processor to transform the notice XML to HTML using the XSLT generated in the previous step. The generated HTML is stored in a local file and can be opened for inspection by the user in any web browser.

== Behind the scenes

The application has a dependency to the `eforms-expression-language` project.

* The application uses the `EfxTemplateTranslator` provided by `eforms-expression-language`.
* To link the translator to the eForms metadata, the application implements the `SymbolResolver` interface in the `SdkSymbolResolver` class.
* To generate XSL, it implements the `ScriptGenerator` interface in the `XslScriptGenerator` class.
* To generate XPath it uses the `XPathScriptGenerator` provided by the `eforms-expression-language` project.

The application also has a dependency to https://mvnrepository.com/artifact/net.sf.saxon/Saxon-HE/11.3[Saxon], which it uses to perform the final XSL transformation that generates the HTML output.

The `EfxTemplateTranslator` is called to translate the EFX template to XSLT. The translator uses the `XPathScriptGenerator` to translate EFX expressions to XPath and the `XslScriptGenerator` to translate the EFX template to XSL markup.

After the XSL is generated, the Saxon XSLT processor is called to apply the XSL transformation to the input XML file. References to labels and field values are resolved (as expected) during this final stage. The label values are resolved directly through the XML files provided in the eForms SDK. 

== Behaviour & known issues
If a label is not found in the available version of the SDK, then the label's identifier is displayed instead.

The CSS stylesheet is very basic and uses several colors to visually identify different types of artefacts in the output. For example, "static" labels are displayed with a different color than "dynamic" labels. A "dynamic" label in this context is a label who's identifier depends on the value of a field (like the label of a codelist or indicator field). Our goal was not to make the notice visually pleasing, but to make the output more clear to a developer exploring the application.

The application does not actually use the correct version of the SDK depending on the provided XML notice. We plan to properly implement this in a future version of the app.

The section numbers displayed in the HTML notice are automatically generated (apart from the ones of root level sections). Some numbers may appear to be skipped in the HTML output. This is because the automatic numbering is currently done when the XSL template is being generated, (instead of the time it is being applied to the input). As a result the numbering of sections follows the list of "anticipated sections" rather than the list of "sections actually present" in the XML input. If a section is not present in the XML input, then the corresponding section will not appear in the HTML output; however, the numbers of subsequent sections will remain unchanged.

